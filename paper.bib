@inproceedings{chlipala2006cooperative,
  title={Cooperative Integration of an Interactive Proof Assistant and an Automated Prover},
  author={Chlipala, Adam and Necula, George C},
  booktitle={The 2006 Federated Logic Conference},
  pages={2},
  year={2006},
  organization={Citeseer}
}



@inbook{moore-1956,
author = {Edward F. Moore},
editor = {C. E. Shannon and J. McCarthy},
doi = {doi:10.1515/9781400882618-006},
url = {https://doi.org/10.1515/9781400882618-006},
title = {Gedanken-Experiments on Sequential Machines},
booktitle = {Automata Studies. (AM-34), Volume 34},
year = {2016},
publisher = {Princeton University Press},
pages = {129--154}
}


@incollection{hopcroft-1971,
  title     = {An $n \log n$ Algorithm for Minimizing States in a Finite Automaton},
  author    = {John Hopcroft},
  booktitle = {Proceedings of an International Symposium on the Theory of Machines and Computations},
  pages     = {189--196},
  year      = {1971},
  publisher = {Academic Press},
  doi       = {10.1016/B978-0-12-417750-5.50022-1},
}

@techreport{hopcroft-karp-1971,
  author    = {John Hopcroft and Richard M. Karp},
  institution =   {Cornell University},
  month     = {December},
  number    = {TR 71-114},
  title     = {A Linear Algorithm for Testing Equivalence of Finite Automata},
  year      = {1971},
  address   = {Ithaca, NY},
  url={https://hdl.handle.net/1813/5958},
}

@article{tarjan-1975,
  author    = {Robert Endre Tarjan},
  title     = {Efficiency of a Good But Not Linear Set Union Algorithm},
  journal   = {J. {ACM}},
  volume    = {22},
  number    = {2},
  pages     = {215--225},
  year      = {1975},
  doi       = {10.1145/321879.321884},
}


@inproceedings{kanellakis-smolka-1983,
author = {Kanellakis, Paris C. and Smolka, Scott A.},
title = {{CCS} Expressions, Finite State Processes, and Three Problems of Equivalence},
year = {1983},
isbn = {0897911105},
url = {https://doi.org/10.1145/800221.806724},
doi = {10.1145/800221.806724},
abstract = {We examine the computational complexity of testing finite state processes for equivalence, in the Calculus of Communicating Systems (CCS). This equivalence problem in CCS is presented as a refinement of the familiar problem of testing whether two nondeterministic finite state automata (n.f.s.a.) accept the same language. Three notions of equivalence, proposed for CCS, are investigated: (1) observation equivalence, (2) congruence, and (3) failure equivalence. We show that observation equivalence (@@@@) can be tested in cubic time and is the limit of a sequence of equivalence notions (@@@@k), where, @@@@1 is the familiar n.f.s.a. equivalence and, for each fixed k, @@@@k is PSPACE-complete. We provide an O(nlogn) test for congruence for n state processes of bounded fanout, by extending the algorithm that minimizes the states of d.f.s.a.'s. Finally, we show that, even for a very restricted type of process, testing for failure equivalence is PSPACE-complete.},
booktitle = {Proc. of the 2nd Annual ACM Symposium on Principles of Distributed Computing},
pages = {228–240},
numpages = {13},
series = {PODC}
}

@article{paige-tarjan-1987,
  author    = {Robert Paige and Robert Endre Tarjan},
  title     = {Three Partition Refinement Algorithms},
  journal   = {{SIAM} Journal on Computing},
  volume    = {16},
  number    = {6},
  pages     = {973--989},
  year      = {1987},
  doi       = {10.1137/0216062},
}

@inproceedings{coudert-etal-1989,
  author    = {Olivier Coudert and Christian Berthet and Jean Christophe Madre},
  title     = {Verification of Synchronous Sequential Machines Based on Symbolic Execution},
  booktitle = {Proc. of Automatic Verification Methods for Finite State Systems},
  pages     = {365--373},
  year      = {1989},
  doi       = {10.1007/3-540-52148-8_30},
}


@inproceedings{bouajjani-etal-1990,
  author    = {Ahmed Bouajjani and Jean{-}Claude Fernandez and Nicolas Halbwachs},
  title     = {Minimal Model Generation},
  booktitle={Proc. of the 2nd International Workshop on Computer Aided Verification},
  year="1991",
  series = {CAV},
  pages     = {197--203},
  doi       = {10.1007/BFb0023733},
}

@article{bouajjani-etal-1992,
  author    = {Ahmed Bouajjani and Jean{-}Claude Fernandez and Nicolas Halbwachs and Pascal Raymond},
  title     = {Minimal State Graph Generation},
  journal={Science of Computer Programming},
  volume={18},
  number={3},
  pages={247--269},
  year={1992},
  doi = {10.1016/0167-6423(92)90018-7},
}

@article{burch-etal-1992,
  author    = {Jerry R. Burch and Edmund M. Clarke and Kenneth L. McMillan and David L. Dill and Lucius J. Hwang},
  title     = {Symbolic Model Checking: $10^{20}$ States and Beyond},
  journal   = {Information and Computation},
  volume    = {98},
  number    = {2},
  pages     = {142--170},
  year      = {1992},
  doi       = {10.1016/0890-5401(92)90017-A},
}

@book{nipkow2002isabelle,
  title={Isabelle/HOL: a proof assistant for higher-order logic},
  author={Nipkow, Tobias and Wenzel, Markus and Paulson, Lawrence C},
  publisher={Springer}
}

@inproceedings{moura2015lean,
  title={The Lean theorem prover (system description)},
  author={Moura, Leonardo de and Kong, Soonho and Avigad, Jeremy and Doorn, Floris van and Raumer, Jakob von},
  booktitle={International Conference on Automated Deduction},
  pages={378--388},
  year={2015},
  organization={Springer}
}

@inproceedings{bouali-desimone-1992,
  author    = {Amar Bouali and Robert de Simone},
  title     = {Symbolic Bisimulation Minimisation},
  booktitle={Proc. of the 4th International Workshop on Computer Aided Verification},
  series = {CAV},
  pages     = {96--108},
  year      = {1992},
  doi       = {10.1007/3-540-56496-9\_9},
}

@article{hennessy-lin-1995,
  author    = {Matthew Hennessy and Huimin Lin},
  title     = {Symbolic Bisimulations},
  journal   = {Theoretical Computer Science},
  volume    = {138},
  number    = {2},
  pages     = {353--389},
  year      = {1995},
  doi       = {10.1016/0304-3975(94)00172-F}
}

@inproceedings{wimmer-etal-2006,
  author    = {Ralf Wimmer and Marc Herbstritt and Holger Hermanns and Kelley Strampp and Bernd Becker},
  title     = {Sigref --- {A} Symbolic Bisimulation Tool Box},
  booktitle = {ATVA},
  pages     = {477--492},
  year      = {2006},
  doi       = {10.1007/11901914\_35},
}

@inproceedings{derisavi-2007,
  author    = {Salem Derisavi},
  title     = {A Symbolic Algorithm for Optimal Markov Chain Lumping},
  booktitle={Proc. of the 13th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  series = {TACAS},
  pages     = {139--154},
  year      = {2007},
  doi       = {10.1007/978-3-540-71209-1\_13},
}

@inproceedings{mumme-ciardo-2011,
  author    = {Malcolm Mumme and Gianfranco Ciardo},
  title     = {A Fully Symbolic Bisimulation Algorithm},
  booktitle = {Proc. of the 5th International Workshop on Reachability Problems},
  series={RP},
  pages     = {218--230},
  year      = {2011},
  doi       = {10.1007/978-3-642-24288-5\_19},
}

@inproceedings{dehnert-etal-2013,
  author    = {Christian Dehnert and Joost{-}Pieter Katoen and David Parker},
  title     = {SMT-Based Bisimulation Minimisation of Markov Models},
  booktitle={Proc. of the 14th International Workshop on Verification, Model Checking, and Abstract Interpretation},
  series = {VMCAI},
  pages     = {28--47},
  year      = {2013},
  doi       = {10.1007/978-3-642-35873-9\_5},
}


@article{feng-etal-2013,
author = {Feng, Yuan and Deng, Yuxin and Ying, Mingsheng},
title = {Symbolic Bisimulation for Quantum Processes},
year = {2014},
issue_date = {April 2014},
volume = {15},
number = {2},
issn = {1529-3785},
url = {https://doi.org/10.1145/2579818},
doi = {10.1145/2579818},
abstract = {With the previous notions of bisimulation presented in the literature, to check if two quantum processes are bisimilar, we have to instantiate their free quantum variables with arbitrary quantum states, and verify the bisimilarity of the resulting configurations. This makes checking bisimilarity infeasible from an algorithmic point of view, because quantum states constitute a continuum. In this article, we introduce a symbolic operational semantics for quantum processes directly at the quantum operation level, which allows us to describe the bisimulation between quantum processes without resorting to quantum states. We show that the symbolic bisimulation defined here is equivalent to the open bisimulation for quantum processes in previous work, when strong bisimulations are considered. An algorithm for checking symbolic ground bisimilarity is presented. We also give a modal characterisation for quantum bisimilarity based on an extension of Hennessy-Milner logic to quantum processes.},
journal = {ACM Transactions on Computational Logic},
month = {May},
articleno = {14},
numpages = {32},
keywords = {quantum processes, symbolic bisimulation, Open bisimulation}
}

@inproceedings{bonchi-pous-2013,
author = {Bonchi, Filippo and Pous, Damien},
title = {Checking NFA Equivalence with Bisimulations up to Congruence},
year = {2013},
isbn = {9781450318327},
url = {https://doi.org/10.1145/2429069.2429124},
doi = {10.1145/2429069.2429124},
abstract = {We introduce bisimulation up to congruence as a technique for proving language equivalence of non-deterministic finite automata. Exploiting this technique, we devise an optimisation of the classical algorithm by Hopcroft and Karp. We compare our approach to the recently introduced antichain algorithms, by analysing and relating the two underlying coinductive proof methods. We give concrete examples where we exponentially improve over antichains; experimental results moreover show non negligible improvements.},
booktitle = {Proc. of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {457–468},
numpages = {12},
keywords = {congruence, coinduction, bisimulation, automata, antichain, up-to techniques, language equivalence},
series = {POPL}
}

  

@inproceedings{dantoni-etal-2018,
  author    = {Loris D'Antoni and Zachary Kincaid and Fang Wang},
  title     = {A Symbolic Decision Procedure for Symbolic Alternating Finite Automata},
  booktitle={Proc. of the 33rd International Conference on the Mathematical Foundations of Programming Semantics (MFPS)},
  booktitle = {MFPS},
  pages     = {79--99},
  year      = {2018},
  doi       = {10.1016/j.entcs.2018.03.017},
}

@book{kurose2005computer,
  title     = {Computer networking: A top-down approach featuring the internet, 3/E},
  author    = {Kurose, James F},
  year      = {2005},
}

@misc{rfc894,
  series    = {Request for Comments},
  number    = 894,
  howpublished = {RFC 894},
  publisher = {IETF},
  doi       = {10.17487/RFC0894},
  url       = {https://rfc-editor.org/rfc/rfc894.txt},
  author    = {Charles Hornig},
  title     = {{A Standard for the Transmission of IP Datagrams over Ethernet Networks}},
  pagetotal = 3,
  year      = 1984,
  month     = apr,
  day       = 1,
}

@misc{rfc791,
  series    = {Request for Comments},
  number    = 791,
  howpublished = {RFC 791},
  publisher = {IETF},
  doi       = {10.17487/RFC0791},
  url       = {https://rfc-editor.org/rfc/rfc791.txt},
  author    = {Jon Postel},
  title     = {{Internet Protocol}},
  pagetotal = 51,
  year      = 1981,
  month     = sep,
  abstract  = {},
}

@misc{rfc3031,
  series    = {Request for Comments},
  number    = 3031,
  howpublished = {RFC 3031},
  publisher = {IETF},
  doi       = {10.17487/RFC3031},
  url       = {https://rfc-editor.org/rfc/rfc3031.txt},
  author    = {Arun Viswanathan and Eric C. Rosen and Ross Callon},
  title     = {{Multiprotocol Label Switching Architecture}},
  pagetotal = 61,
  year      = 2001,
  month     = jan,
}

@misc{rfc793,
  series    = {Request for Comments},
  number    = 793,
  howpublished = {RFC 793},
  publisher = {IETF},
  doi       = {10.17487/RFC0793},
  url       = {https://rfc-editor.org/rfc/rfc793.txt},
  author    = {Jon Postel},
  title     = {{Transmission Control Protocol}},
  pagetotal = 91,
  year      = 1981,
  month     = sep,
}

@misc{rfc768,
  series    = {Request for Comments},
  number    = 768,
  howpublished ={RFC 768},
  publisher = {IETF},
  doi       = {10.17487/RFC0768},
  url       = {https://rfc-editor.org/rfc/rfc768.txt},
  author    = {Jon Postel},
  title     = {{User Datagram Protocol}},
  pagetotal = 3,
  year      = 1980,
  month     = aug,
}

@Manual{p4-spec,
  title     = {P4 Language Specification, Version 1.2.2},
  author    = {The P4 Language Consortium},
  year      = 2021,
  month     = may,
  note      = {Available at \url{https://p4.org/p4-spec/docs/P4-16-v1.2.2.html}.},
}

@inproceedings{sangiorgi-1995,
  author    = {Davide Sangiorgi},
  title     = {On the Proof Method for Bisimulation (Extended Abstract)},
  booktitle = {MFCS},
  pages     = {479--488},
  year      = {1995},
}

@article{ringer2019qed,
  title={QED at large: A survey of engineering of formally verified software},
  author={Ringer, Talia and Palmskog, Karl and Sergey, Ilya and Gligoric, Milos and Tatlock, Zachary and others},
  journal={Foundations and Trends{\textregistered} in Programming Languages},
  volume={5},
  number={2-3},
  pages={102--281},
  year={2019},
  publisher={Now Publishers, Inc.}
}

@article{constable1990implementing,
  title={Implementing Mathematics with the Nuprl Proof Development System},
  author={Constable, RL and Allen, SF and Bromley, HM and Cleaveland, WR and Cremer, JF and Harper, RW},
  journal={Journal of Symbolic Logic},
  volume={55},
  number={3},
  year={1990}
}

@book{bertot2013interactive,
  author    = {Yves Bertot and
               Pierre Cast{\'{e}}ran},
  title     = {Interactive Theorem Proving and Program Development - Coq'Art: The
               Calculus of Inductive Constructions},
  series    = {Texts in Theoretical Computer Science. An {EATCS} Series},
  year      = {2004},
  doi       = {10.1007/978-3-662-07964-5},
  isbn      = {978-3-642-05880-6},
}

@inproceedings{gibb2013design,
  author    = {Glen Gibb and
               George Varghese and
               Mark Horowitz and
               Nick McKeown},
  title     = {Design Principles for Packet Parsers},
  booktitle={Proc. of the 9th ACM/IEEE Symposium on Architecture for Networking and Communications Systems},
  series = {ANCS},
  pages     = {13--24},
  year      = {2013},
  doi       = {10.1109/ANCS.2013.6665172},
}

@article{vlanieee,
  author    = {{IEEE Computer Society}},
  journal   = {IEEE Std 802.1Q-2018 (Revision of IEEE Std 802.1Q-2014)}, 
  title     = {IEEE Standard for Local and Metropolitan Area Network--Bridges and Bridged Networks}, 
  year      = {2018},
  pages     = {1-1993},
  doi       = {10.1109/IEEESTD.2018.8403927}
}

@online{ip-params,
  author    = {Internet Assigned Numbers Authority},
  title     = {Internet Protocol Version 4 (IPv4) Parameters},
  year      = 2018,
  url       = {https://www.iana.org/assignments/ip-parameters/ip-parameters.xhtml},
  urldate   = {2021-11-19}
}


@inproceedings{gauthier2015premise,
  title={Premise selection and external provers for HOL4},
  author={Gauthier, Thibault and Kaliszyk, Cezary},
  booktitle={Proceedings of the 2015 Conference on Certified Programs and Proofs},
  pages={49--57},
  year={2015}
}

@inproceedings{besson2021itauto,
  title={Itauto: An Extensible Intuitionistic SAT Solver},
  author={Besson, Fr{\'e}d{\'e}ric},
  booktitle={12th International Conference on Interactive Theorem Proving (ITP 2021)},
  year={2021},
  organization={Schloss Dagstuhl-Leibniz-Zentrum f{\"u}r Informatik}
}

@article{blot2021general,
  title={General Automation in Coq through Modular Transformations},
  author={Blot, Valentin and de Prisque, Louise Dubois and Keller, Chantal and Vial, Pierre},
  journal={Electronic Proceedings in Theoretical Computer Science},
  year={2021}
}

@inproceedings{hur2020equational,
author = {Zakowski, Yannick and He, Paul and Hur, Chung-Kil and Zdancewic, Steve},
title = {An Equational Theory for Weak Bisimulation via Generalized Parameterized Coinduction},
year = {2020},
isbn = {9781450370974},
url = {https://doi.org/10.1145/3372885.3373813},
doi = {10.1145/3372885.3373813},
abstract = {Coinductive reasoning about infinitary structures such as streams is widely applicable. However, practical frameworks for developing coinductive proofs and finding reasoning principles that help structure such proofs remain a challenge, especially in the context of machine-checked formalization. This paper gives a novel presentation of an equational theory for reasoning about structures up to weak bisimulation. The theory is both compositional, making it suitable for defining general-purpose lemmas, and also incremental, meaning that the bisimulation can be created interactively. To prove the theory’s soundness, this paper also introduces generalized parameterized coinduction, which addresses expressivity problems of earlier works and provides a practical framework for coinductive reasoning. The paper presents the resulting equational theory for streams, but the technique applies to other structures too. All of the results in this paper have been proved in Coq, and the generalized parameterized coinduction framework is available as a Coq library.},
booktitle = {Proc. of the 9th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {71-84},
numpages = {14},
keywords = {Coq, equational theory, weak bisimulation, coinduction, up-to techniques},
series = {CPP}
}

@inproceedings{czajka2020practical,
  title={Practical proof search for Coq by type inhabitation},
  author={Czajka, {\L}ukasz},
  booktitle={International Joint Conference on Automated Reasoning},
  pages={28--57},
  year={2020},
  organization={Springer}
}

@Inproceedings{EPTCS336.3,
  author    = {Blot, Valentin and Dubois de Prisque, Louise and Keller, Chantal and Vial, Pierre},
  year      = {2021},
  title     = {General Automation in Coq through Modular Transformations},
  editor    = {Keller, Chantal and Fleury, Mathias},
  booktitle = {{\rm Proceedings Seventh Workshop on}
               Proof eXchange for Theorem Proving,
               {\rm Pittsburg, USA, 11th July 2021}},
  series    = {Electronic Proceedings in Theoretical Computer Science},
  volume    = {336},
  publisher = {Open Publishing Association},
  pages     = {24-39},
  doi       = {10.4204/EPTCS.336.3},
}

@misc{sniper-latest,
  doi = {10.48550/ARXIV.2204.02643},
  
  url = {https://arxiv.org/abs/2204.02643},
  
  author = {Blot, Valentin and Cousineau, Denis and Crance, Enzo and de Prisque, Louise Dubois and Keller, Chantal and Mahboubi, Assia and Vial, Pierre},
  
  keywords = {Logic in Computer Science (cs.LO), FOS: Computer and information sciences, FOS: Computer and information sciences},
  
  title = {Compositional pre-processing for automated reasoning in dependent type theory},
  
  publisher = {arXiv},
  
  year = {2022},
  
  copyright = {Creative Commons Attribution 4.0 International}
}

@inproceedings{boston2021verified,
  title={Verified cryptographic code for everybody},
  author={Boston, Brett and Breese, Samuel and Dodds, Joey and Dodds, Mike and Huffman, Brian and Petcher, Adam and Stefanescu, Andrei},
  booktitle={International Conference on Computer Aided Verification},
  pages={645--668},
  year={2021},
  organization={Springer}
}

@article{d2008survey,
  title={A survey of automated techniques for formal software verification},
  author={D'silva, Vijay and Kroening, Daniel and Weissenbacher, Georg},
  journal={IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
  volume={27},
  number={7},
  pages={1165--1178},
  year={2008},
  publisher={IEEE}
}

@inproceedings{hur2013power,
  title={The Power of Parameterization in Coinductive Proof},
  author={Hur, Chung-Kil and Neis, Georg and Dreyer, Derek and Vafeiadis, Viktor},
  booktitle={Proc. of the 40th annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  series={POPL},
  pages={193--206},
  year={2013},
issue_date = {January 2013},
url = {https://doi.org/10.1145/2480359.2429093},
doi = {10.1145/2480359.2429093},
}



@inproceedings{armand-etal-2011,
  author    = {Micha{\"{e}}l Armand and Germain Faure and Benjamin Gr{\'{e}}goire and Chantal Keller and Laurent Th{\'{e}}ry and Benjamin Werner},
  title     = {A Modular Integration of {SAT/SMT} Solvers to Coq through Proof Witnesses},
  booktitle={Proc. of the International Conference on Certified Programs and Proofs},
  series = {CPP},
  pages     = {135--150},
  year      = {2011},
  doi       = {10.1007/978-3-642-25379-9\_12},
}

@inproceedings{barrett-etal-2011,
  author    = {Clark W. Barrett and Christopher L. Conway and Morgan Deters and Liana Hadarean and Dejan Jovanovic and Tim King and Andrew Reynolds and Cesare Tinelli},
  title     = {{CVC4}},
  booktitle={Proc. of Computer Aided Verification},
  series = {CAV},
  pages     = {171--177},
  year      = {2011},
  doi       = {10.1007/978-3-642-22110-1\_14},
}

@article{niemetz-etal-2014,
  author    = {Aina Niemetz and Mathias Preiner and Armin Biere},
  title     = {Boolector 2.0},
  journal   = {Journal on Satisfiability, Boolean Modeling and Computation},
  volume    = {9},
  number    = {1},
  pages     = {53--58},
  year      = {2014},
  doi       = {10.3233/sat190101},
}

@article{streicher-1993,
  title     = {Investigations into Intensional Type Theory},
  author    = {Streicher, Thomas},
  journal   = {Habilitiation Thesis, Ludwig Maximilian Universit{\"a}t},
  year      = {1993},
  url={https://www2.mathematik.tu-darmstadt.de/~streicher/HabilStreicher.pdf},
}

@article{10.1145/3473589,
author = {Watanabe, Yasunari and Gopinathan, Kiran and P\^{\i}rlea, George and Polikarpova, Nadia and Sergey, Ilya},
title = {Certifying the Synthesis of Heap-Manipulating Programs},
year = {2021},
issue_date = {August 2021},
volume = {5},
number = {ICFP},
url = {https://doi.org/10.1145/3473589},
doi = {10.1145/3473589},
abstract = {Automated deductive program synthesis promises to generate executable programs from concise specifications, along with proofs of correctness that can be independently verified using third-party tools. However, an attempt to exercise this promise using existing proof-certification frameworks reveals significant discrepancies in how proof derivations are structured for two different purposes: program synthesis and program verification. These discrepancies make it difficult to use certified verifiers to validate synthesis results, forcing one to write an ad-hoc translation procedure from synthesis proofs to correctness proofs for each verification backend.  In this work, we address this challenge in the context of the synthesis and verification of heap-manipulating programs. We present a technique for principled translation of deductive synthesis derivations (a.k.a. source proofs) into deductive target proofs about the synthesised programs in the logics of interactive program verifiers. We showcase our technique by implementing three different certifiers for programs generated via SuSLik, a Separation Logic-based tool for automated synthesis of programs with pointers, in foundational verification frameworks embedded in Coq: Hoare Type Theory (HTT), Iris, and Verified Software Toolchain (VST), producing concise and efficient machine-checkable proofs for characteristic synthesis benchmarks.},
journal = {Proceedings of the ACM on Programming Languages},
month = aug,
articleno = {84},
numpages = {29},
keywords = {Program Synthesis, Separation Logic, Proof Assistants, Mechanised Proofs}
}

@article{spacesearch,
author = {Weitz, Konstantin and Lyubomirsky, Steven and Heule, Stefan and Torlak, Emina and Ernst, Michael D. and Tatlock, Zachary},
title = {SpaceSearch: A Library for Building and Verifying Solver-Aided Tools},
year = {2017},
issue_date = {September 2017},
volume = {1},
number = {ICFP},
url = {https://doi.org/10.1145/3110269},
doi = {10.1145/3110269},
abstract = { Many verification tools build on automated solvers. These tools reduce problems in a specific application domain (e.g., compiler optimization validation) to queries that can be discharged with a highly optimized solver. But the correctness of the reductions themselves is rarely verified in practice, limiting the confidence that the solver's output establishes the desired domain-level property.  This paper presents SpaceSearch, a new library for developing solver-aided tools within a proof assistant. A user builds their solver-aided tool in Coq against the SpaceSearch interface, and the user then verifies that the results provided by the interface are sufficient to establish the tool's desired high-level properties. Once verified, the tool can be extracted to an implementation in a solver-aided language (e.g., Rosette), where SpaceSearch provides an efficient instantiation of the SpaceSearch interface with calls to an underlying SMT solver. This combines the strong correctness guarantees of developing a tool in a proof assistant with the high performance of modern SMT solvers. This paper also introduces new optimizations for such verified solver-aided tools, including parallelization and incrementalization.  We evaluate SpaceSearch by building and verifying two solver-aided tools. The first, SaltShaker, checks that RockSalt's x86 semantics for a given instruction agrees with STOKE's x86 semantics. SaltShaker identified 7 bugs in RockSalt and 1 bug in STOKE. After these systems were patched by their developers, SaltShaker verified the semantics' agreement on 15,255 instruction instantiations in under 2h. The second tool, BGProof, is a verified version of an existing Border Gateway Protocol (BGP) router configuration checker. Like the existing checker, BGProof scales to checking industrial configurations spanning over 240 KLOC, identifying 19 configuration inconsistencies with no false positives. However, the correctness of BGProof has been formally proven, and we found 2 bugs in the unverified implementation. These results demonstrate that SpaceSearch is a practical approach to developing efficient, verified solver-aided tools. },
journal = {Proceedings of the ACM on Programming Languages},
month = aug,
articleno = {25},
numpages = {28},
keywords = {Bagpipe, SMT solver-aided tools, SaltShaker, Coq}
}


@inproceedings{crellvm,
author = {Kang, Jeehoon and Kim, Yoonseung and Song, Youngju and Lee, Juneyoung and Park, Sanghoon and Shin, Mark Dongyeon and Kim, Yonghyun and Cho, Sungkeun and Choi, Joonwon and Hur, Chung-Kil and Yi, Kwangkeun},
title = {Crellvm: Verified Credible Compilation for LLVM},
year = {2018},
isbn = {9781450356985},
url = {https://doi.org/10.1145/3192366.3192377},
doi = {10.1145/3192366.3192377},
abstract = {Production compilers such as GCC and LLVM are large complex software systems, for which achieving a high level of reliability is hard. Although testing is an effective method for finding bugs, it alone cannot guarantee a high level of reliability. To provide a higher level of reliability, many approaches that examine compilers' internal logics have been proposed. However, none of them have been successfully applied to major optimizations of production compilers.  This paper presents Crellvm: a verified credible compilation framework for LLVM, which can be used as a systematic way of providing a high level of reliability for major optimizations in LLVM. Specifically, we augment an LLVM optimizer to generate translation results together with their correctness proofs, which can then be checked by a proof checker formally verified in Coq. As case studies, we applied our approach to two major optimizations of LLVM: register promotion mem2reg and global value numbering gvn, having found four new miscompilation bugs (two in each).},
booktitle = {Proc. of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {631–645},
numpages = {15},
keywords = {LLVM, compiler verification, credible compilation, relational Hoare logic, translation validation, Coq},
series = {PLDI}
}


@inproceedings{neves-p4,
author = {Neves, Miguel and Freire, Lucas and Schaeffer-Filho, Alberto and Barcellos, Marinho},
title = {Verification of P4 Programs in Feasible Time Using Assertions},
year = {2018},
isbn = {9781450360807},
url = {https://doi.org/10.1145/3281411.3281421},
doi = {10.1145/3281411.3281421},
abstract = {Recent trends in software-defined networking have extended network programmability to the data plane. Unfortunately, the chance of introducing bugs increases significantly. Verification can help prevent bugs by assuring that the program does not violate its requirements. Although research on the verification of P4 programs is very active, we still need tools to make easier for programmers to express properties and to rapidly verify complex invariants. In this paper, we leverage assertions and symbolic execution to propose a more general P4 verification approach. Developers annotate P4 programs with assertions expressing general network correctness properties; the result is transformed into C models and all possible paths symbolically executed. We implement a prototype, and use it to show the feasibility of the verification approach. Because symbolic execution does not scale well, we investigate a set of techniques to speed up the process for the specific case of P4 programs. We use the prototype implemented to show the gains provided by three speed up techniques (use of constraints, program slicing, parallelization), and experiment with different compiler optimization choices. We show our tool can uncover a broad range of bugs, and can do it in less than a minute considering various P4 applications.},
booktitle = {Proc. of the 14th International Conference on Emerging Networking EXperiments and Technologies},
pages = {73–85},
numpages = {13},
keywords = {P4, verification, programmable data planes},
series = {CoNEXT}
}

@article{narcissus,
author    = {Benjamin Delaware and
               Sorawit Suriyakarn and
               Cl{\'{e}}ment Pit{-}Claudel and
               Qianchuan Ye and
               Adam Chlipala},
title = {Narcissus: Correct-by-Construction Derivation of Decoders and Encoders from Binary Formats},
year = {2019},
issue_date = {August 2019},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341686},
doi = {10.1145/3341686},
abstract = {It is a neat result from functional programming that libraries of parser combinators can support rapid construction of decoders for quite a range of formats. With a little more work, the same combinator program can denote both a decoder and an encoder. Unfortunately, the real world is full of gnarly formats, as with the packet formats that make up the standard Internet protocol stack. Most past parser-combinator approaches cannot handle these formats, and the few exceptions require redundancy – one part of the natural grammar needs to be hand-translated into hints in multiple parts of a parser program. We show how to recover very natural and nonredundant format specifications, covering all popular network packet formats and generating both decoders and encoders automatically. The catch is that we use the Coq proof assistant to derive both kinds of artifacts using tactics, automatically, in a way that guarantees that they form inverses of each other. We used our approach to reimplement packet processing for a full Internet protocol stack, inserting our replacement into the OCaml-based MirageOS unikernel, resulting in minimal performance degradation.},
journal = {Proceedings of the ACM on Programming Languages},
month = {July},
articleno = {82},
numpages = {29},
keywords = {Deductive Synthesis, Program Synthesis, Parser Combinators, Serialization and Deserialization}
}

@inproceedings {everparse,
author    = {Tahina Ramananandro and
               Antoine Delignat{-}Lavaud and
               C{\'{e}}dric Fournet and
               Nikhil Swamy and
               Tej Chajed and
               Nadim Kobeissi and
               Jonathan Protzenko},
title = {{EverParse}: Verified Secure {Zero-Copy} Parsers for Authenticated Message Formats},
booktitle = {28th USENIX Security Symposium},
series={USENIX Security},
year = {2019},
isbn = {978-1-939133-06-9},
pages = {1465--1482},
url = {https://www.usenix.org/conference/usenixsecurity19/presentation/delignat-lavaud},
month = aug,
}

@article{deepspec,
  title     = {Position paper: the Science of Deep Specification},
  author    = {Appel, Andrew W. and Beringer, Lennart and Chlipala, Adam and Pierce, Benjamin C. and Shao, Zhong and Weirich, Stephanie and Zdancewic, Steve},
  journal={Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
  volume    = {375},
  number    = {2104},
  pages     = {20160331},
  year      = {2017},
  doi       = {10.1098/rsta.2016.0331},
}


@inproceedings{verified-lcm,
  author    = {Jean{-}Baptiste Tristan and
               Xavier Leroy},
title = {Verified Validation of Lazy Code Motion},
year = {2009},
isbn = {9781605583921},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1542476.1542512},
doi = {10.1145/1542476.1542512},
abstract = {Translation validation establishes a posteriori the correctness of a run of a compilation pass or other program transformation. In this paper, we develop an efficient translation validation algorithm for the Lazy Code Motion (LCM) optimization. LCM is an interesting challenge for validation because it is a global optimization that moves code across loops. Consequently, care must be taken not to move computations that may fail before loops that may not terminate. Our validator includes a specific check for anticipability to rule out such incorrect moves. We present a mechanically-checked proof of correctness of the validation algorithm, using the Coq proof assistant. Combining our validator with an unverified implementation of LCM, we obtain a LCM pass that is provably semantics-preserving and was integrated in the CompCert formally verified compiler.},
booktitle = {Proc. of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {316–326},
numpages = {11},
keywords = {verified compilers, translation validation, the coq proof assistant, redundancy elimination, lazy code motion},
series = {PLDI}
}

  

@book{vstbook,
  author={Appel, Andrew W. and Dockins, Robert and Hobor, Aquinas and Beringer, Lennart and Dodds, Josiah and Stewart, Gordon and Blazy, Sandrine and Leroy, Xavier},
  title     = {Program Logics for Certified Compilers},
  publisher = {Cambridge University Press},
  year      = {2014},
  isbn      = {978-1-10-704801-0},
}

@inproceedings{necula-tv,
author = {Necula, George C.},
title = {Translation Validation for an Optimizing Compiler},
year = {2000},
isbn = {1581131992},
url = {https://doi.org/10.1145/349299.349314},
doi = {10.1145/349299.349314},
abstract = {We describe a translation validation infrastructure for the GNU C 
compiler. During the compilation the infrastructure compares the intermediate form of the program before and after each compiler pass and verifies the preservation of semantics. We discuss a general framework that the optimizer can use to communicate to the validator what transformations were performed. Our implementation however does not rely on help from the optimizer and it is quite successful by using instead a few heuristics to detect the transformations that take place.The main message of this paper is that a practical translation validation infrastructure, able to check the correctness of many of the transformations performed by a realistic compiler, can be implemented with about the effort typically required to implement one compiler pass. We demonstrate this in the context of the GNU C compiler for a number of its optimizations while compiling realistic programs such as the compiler itself or the Linux kernel. We believe that the price of such an infrastructure is small considering the qualitative increase in the ability to isolate compilation errors during compiler testing and maintenance.},
booktitle = {Proc. of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation},
pages = {83–94},
numpages = {12},
series = {PLDI}
}

@inproceedings{rakamaric2014smack,
  title={SMACK: Decoupling source language details from verifier implementations},
  author={Rakamari{\'c}, Zvonimir and Emmi, Michael},
  booktitle={International Conference on Computer Aided Verification},
  pages={106--113},
  year={2014},
  organization={Springer}
}

  


@inproceedings{massalin1987superoptimizer,
author = {Massalin, Henry},
title = {Superoptimizer: A Look at the Smallest Program},
year = {1987},
isbn = {0818608056},
url = {https://dl.acm.org/doi/10.1145/36177.36194},
doi = {10.1145/36177.36194},
abstract = {Given an instruction set, the superoptimizer finds the shortest program to compute a function. Startling programs have been generated, many of them engaging in convoluted bit-fiddling bearing little resemblance to the source programs which defined the functions. The key idea in the superoptimizer is a probabilistic test that makes exhaustive searches practical for programs of useful size. The search space is defined by the processor's instruction set, which may include the whole set, but it is typically restricted to a subset. By constraining the instructions and observing the effect on the output program, one can gain insight into the design of instruction sets. In addition, superoptimized programs may be used by peephole optimizers to improve the quality of generated code, or by assembly language programmers to improve manually written code.},
booktitle = {Proc. of the 2nd International Conference on Architectual Support for Programming Languages and Operating Systems},
pages = {122–126},
numpages = {5},
series = {ASPLOS}
}


@article{gulwani2017program,
url = {http://dx.doi.org/10.1561/2500000010},
year = {2017},
volume = {4},
journal = {Foundations and Trends® in Programming Languages},
title = {Program Synthesis},
doi = {10.1561/2500000010},
issn = {2325-1107},
number = {1-2},
pages = {1-119},
author = {Sumit Gulwani and Oleksandr Polozov and Rishabh Singh}
}


@inproceedings{sozeau-2010,
author="Sozeau, Matthieu",
editor="Kaufmann, Matt
and Paulson, Lawrence C.",
title="Equations: A Dependent Pattern-Matching Compiler",
booktitle="Interactive Theorem Proving",
year="2010",
pages="419--434",
abstract="We present a compiler for definitions made by pattern matching on inductive families in the Coq system. It allows to write structured, recursive dependently-typed functions as a set of equations, automatically find their realization in the core type theory and generate proofs to ease reasoning on them. It provides a complete package to define and reason on functions in the proof assistant, substantially reducing the boilerplate code and proofs one usually has to write, also hiding the intricacies related to the use of dependent types and complex recursion schemes.",
isbn="978-3-642-14052-5",
booktitle={Proc. of 1st International Conference on Interactive Theorem Proving},
series={ITP},
doi       = {10.1007/978-3-642-14052-5\_29},
}


@article{sozeau-mangin-2019,
author = {Sozeau, Matthieu and Mangin, Cyprien},
title = {Equations Reloaded: High-Level Dependently-Typed Functional Programming and Proving in Coq},
year = {2019},
issue_date = {August 2019},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341690},
doi = {10.1145/3341690},
abstract = {Equations is a plugin for the Coq proof assistant which provides a notation for defining programs by dependent pattern-matching and structural or well-founded recursion. It additionally derives useful high-level proof principles for demonstrating properties about them, abstracting away from the implementation details of the function and its compiled form. We present a general design and implementation that provides a robust and expressive function definition package as a definitional extension to the Coq kernel. At the core of the system is a new simplifier for dependent equalities based on an original handling of the no-confusion property of constructors.},
journal   = {Proceedings of the ACM on Programming Languages},
month = {Jul},
articleno = {86},
numpages = {29},
keywords = {dependent pattern-matching, proof assistants, recursion}
}


@book{mahboubi2017mathematical,
  author       = {Assia Mahboubi and
                  Enrico Tassi},
  title        = {Mathematical Components},
  publisher    = {Zenodo},
  year         = 2021,
  month        = {Jan},
  doi          = {10.5281/zenodo.4457887},
  url          = {https://doi.org/10.5281/zenodo.4457887}
}

@inproceedings{appel2011verified,
  title={Verified Software Toolchain},
  author={Appel, Andrew W.},
  booktitle={Proc. of European Symposium on Programming},
  series={ESOP},
  pages={1--17},
  year={2011},
  doi={10.1007/978-3-642-19718-5\_1},
}


@inproceedings{de2008z3,
  author    = {Leonardo de Moura and
               Nikolaj Bj{\o}rner},
  title     = {{Z3:} An Efficient {SMT} Solver},
  booktitle={Proc. of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  series = {TACAS},
  pages     = {337--340},
  year      = {2008},
  doi       = {10.1007/978-3-540-78800-3\_24},
}

@article{langsec,
  author    = {Len Sassaman and
               Meredith L. Patterson and
               Sergey Bratus and
               Michael E. Locasto},
  title     = {Security Applications of Formal Language Theory},
  journal   = {{IEEE} Systems Journal},
  volume    = {7},
  number    = {3},
  pages     = {489--500},
  year      = {2013},
  doi       = {10.1109/JSYST.2012.2222000},
}

@inproceedings{p4v,
author = {Liu, Jed and Hallahan, William and Schlesinger, Cole and Sharif, Milad and Lee, Jeongkeun and Soul\'{e}, Robert and Wang, Han and Ca\c{s}caval, C\u{a}lin and McKeown, Nick and Foster, Nate},
title = {P4v: Practical Verification for Programmable Data Planes},
year = {2018},
isbn = {9781450355674},
url = {https://doi.org/10.1145/3230543.3230582},
doi = {10.1145/3230543.3230582},
abstract = {We present the design and implementation of p4v, a practical tool for verifying data planes described using the P4 programming language. The design of p4v is based on classic verification techniques but adds several key innovations including a novel mechanism for incorporating assumptions about the control plane and domain-specific optimizations which are needed to scale to large programs. We present case studies showing that p4v verifies important properties and finds bugs in real-world programs. We conduct experiments to quantify the scalability of p4v on a wide range of additional examples. We show that with just a few hundred lines of control-plane annotations, p4v is able to verify critical safety properties for switch.p4, a program that implements the functionality of on a modern data center switch, in under three minutes.},
booktitle = {Proc. of the 2018 Conference of the ACM Special Interest Group on Data Communication},
pages = {490–503},
numpages = {14},
keywords = {programmable data planes, verification, P4},
series = {SIGCOMM}
}

@article{p4paper,
author = {Bosshart, Pat and Daly, Dan and Gibb, Glen and Izzard, Martin and McKeown, Nick and Rexford, Jennifer and Schlesinger, Cole and Talayco, Dan and Vahdat, Amin and Varghese, George and Walker, David},
title = {P4: Programming Protocol-Independent Packet Processors},
year = {2014},
issue_date = {July 2014},
volume = {44},
number = {3},
issn = {0146-4833},
url = {https://doi.org/10.1145/2656877.2656890},
doi = {10.1145/2656877.2656890},
abstract = {P4 is a high-level language for programming protocol-independent packet processors. P4 works in conjunction with SDN control protocols like OpenFlow. In its current form, OpenFlow explicitly specifies protocol headers on which it operates. This set has grown from 12 to 41 fields in a few years, increasing the complexity of the specification while still not providing the flexibility to add new headers. In this paper we propose P4 as a strawman proposal for how OpenFlow should evolve in the future. We have three goals: (1) Reconfigurability in the field: Programmers should be able to change the way switches process packets once they are deployed. (2) Protocol independence: Switches should not be tied to any specific network protocols. (3) Target independence: Programmers should be able to describe packet-processing functionality independently of the specifics of the underlying hardware. As an example, we describe how to use P4 to configure a switch to add a new hierarchical label.},
journal = {ACM SIGCOMM Comput. Commun. Rev.},
month = jul,
pages = {87–95},
numpages = {9},
keywords = {protocol-independent, p4, sdn, reconfigurability}
}

@inproceedings{aquila,
author = {Tian, Bingchuan and Gao, Jiaqi and Liu, Mengqi and Zhai, Ennan and Chen, Yanqing and Zhou, Yu and Dai, Li and Yan, Feng and Ma, Mengjing and Tang, Ming and Lu, Jie and Wei, Xionglie and Liu, Hongqiang Harry and Zhang, Ming and Tian, Chen and Yu, Minlan},
title = {Aquila: A Practically Usable Verification System for Production-Scale Programmable Data Planes},
year = {2021},
isbn = {9781450383837},
url = {https://doi.org/10.1145/3452296.3472937},
doi = {10.1145/3452296.3472937},
abstract = {This paper presents Aquila, the first practically usable verification system for Alibaba's production-scale programmable data planes. Aquila addresses four challenges in building a practically usable verification: (1) specification complexity; (2) verification scalability; (3) bug localization; and (4) verifier self validation. Specifically, first, Aquila proposes a high-level language that facilitates easy expression of specifications, reducing lines of specification codes by tenfold compared to the state-of-the-art. Second, Aquila constructs a sequential encoding algorithm to circumvent the exponential growth of states associated with the upscaling of data plane programs to production level. Third, Aquila adopts an automatic and accurate bug localization approach that can narrow down suspects based on reported violations and pinpoint the culprit by simulating a fix for each suspect. Fourth and finally, Aquila can perform self validation based on refinement proof, which involves the construction of an alternative representation and subsequent equivalence checking. To this date, Aquila has been used in the verification of our production-scale programmable edge networks for over half a year, and it has successfully prevented many potential failures resulting from data plane bugs.},
booktitle = {Proc. of the 2021 ACM SIGCOMM 2021 Conference},
pages = {17–32},
numpages = {16},
keywords = {P4 verification, programmable switches, formal methods},
series = {SIGCOMM}
}

@article{vazou2017refinement,
  title={Refinement reflection: complete verification with SMT},
  author={Vazou, Niki and Tondwalkar, Anish and Choudhury, Vikraman and Scott, Ryan G and Newton, Ryan R and Wadler, Philip and Jhala, Ranjit},
  journal={Proceedings of the ACM on Programming Languages},
  volume={2},
  number={POPL},
  pages={1--31},
  year={2017},
  publisher={ACM New York, NY, USA}
}

@inproceedings{barrett-etal-2010,
  author    = {Clark W. Barrett and Aaron Stump and Cesare Tinelli},
  title     = {{The SMT-LIB Standard: Version 2.0}},
  booktitle = {Proc. of the 8th International Workshop on Satisfiability Modulo Theories},
  series={SMT},
  year  = 2010,
  pages={14-14},
  volume={13},
}

@article{blanchette2016hammering,
  title={Hammering towards QED},
  author={Blanchette, Jasmin Christian and Kaliszyk, Cezary and Paulson, Lawrence C and Urban, Josef},
  journal={Journal of Formalized Reasoning},
  volume={9},
  number={1},
  pages={101--148},
  year={2016}
}

@article{czajka-kaliszyk-2018,
  author    = {Lukasz Czajka and Cezary Kaliszyk},
  title     = {Hammer for Coq: Automation for Dependent Type Theory},
  journal   = {J. Autom. Reason.},
  volume    = {61},
  number    = {1-4},
  pages     = {423--453},
  year      = {2018},
  doi       = {10.1007/s10817-018-9458-4},
}

@inproceedings{ekici-etal-2017,
  author    = {Burak Ekici and Alain Mebsout and Cesare Tinelli and Chantal Keller and Guy Katz and Andrew Reynolds and Clark W. Barrett},
  title     = {SMTCoq: {A} Plug-In for Integrating {SMT} Solvers into Coq},
  booktitle = {CAV},
  pages     = {126--133},
  year      = {2017},
  url       = {https://doi.org/10.1007/978-3-319-63390-9\_7},
  doi       = {10.1007/978-3-319-63390-9_7},
}

@inproceedings{10.1145/3314221.3314596,
  author = {Churchill, Berkeley and Padon, Oded and Sharma, Rahul and Aiken, Alex},
  title = {Semantic Program Alignment for Equivalence Checking},
  year = {2019},
  isbn = {9781450367127},
  url = {https://doi.org/10.1145/3314221.3314596},
  doi = {10.1145/3314221.3314596},
  abstract = {We introduce a robust semantics-driven technique for program equivalence checking. Given two functions we find a trace alignment over a set of concrete executions of both programs and construct a product program particularly amenable to checking equivalence.  We demonstrate that our algorithm is applicable to challenging equivalence problems beyond the scope of existing techniques. For example, we verify the correctness of the hand-optimized vector implementation of strlen that ships as part of the GNU C Library, as well as the correctness of vectorization optimizations for 56 benchmarks derived from the Test Suite for Vectorizing Compilers.},
  booktitle = {Proc. of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages = {1027–1040},
  numpages = {14},
  keywords = {verification, equivalence checking},
  series = {PLDI}
}


@article{dijkstra-1975,
author = {Dijkstra, Edsger W.},
title = {Guarded Commands, Nondeterminacy and Formal Derivation of Programs},
year = {1975},
issue_date = {Aug. 1975},
volume = {18},
number = {8},
issn = {0001-0782},
url = {https://doi.org/10.1145/360933.360975},
doi = {10.1145/360933.360975},
abstract = {So-called “guarded commands” are introduced as a building block for alternative and repetitive constructs that allow nondeterministic program components for which at least the activity evoked, but possibly even the final state, is not necessarily uniquely determined by the initial state. For the formal derivation of programs expressed in terms of these constructs, a calculus will be be shown.},
journal   = {Communications of the {ACM}},
month = aug,
pages = {453–457},
numpages = {5},
keywords = {repetition, program semantics, correctness proof, programming language semantics, sequencing primitives, derivation of programs, programming languages, programming methodology, nondeterminancy, case-construction, termination}
}

@inproceedings{gimenez1994codifying,
author = {Gim\'{e}nez, Eduardo},
title = {Codifying Guarded Definitions with Recursive Schemes},
year = {1994},
isbn = {3540605797},
booktitle = {Proc. of the International Workshop on Types for Proofs and Programs},
pages = {39–59},
numpages = {21},
series = {TYPES},
doi={10.1007/3-540-60579-7_3},
}

@inproceedings{DBLP:conf/rta/TimanyS18,
  author    = {Amin Timany and
               Matthieu Sozeau},
  title     = {Cumulative Inductive Types In Coq},
  booktitle = {{FSCD}},
  series    = {LIPIcs},
  volume    = {108},
  pages     = {29:1--29:16},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year      = {2018}
}

@inproceedings{leino-2010,
  author    = {K. Rustan M. Leino},
  title     = {Dafny: An Automatic Program Verifier for Functional Correctness},
  booktitle = {LPAR},
  pages     = {348--370},
  year      = {2010},
  doi       = {10.1007/978-3-642-17511-4_20},
}

@inproceedings{blanc2013overview,
  title={An overview of the Leon verification system: Verification by translation to recursive functions},
  author={Blanc, R{\'e}gis and Kuncak, Viktor and Kneuss, Etienne and Suter, Philippe},
  booktitle={Proceedings of the 4th Workshop on Scala},
  pages={1--10},
  year={2013}
}

@inproceedings{doenges2022leapfrog,
  title={Leapfrog: certified equivalence for protocol parsers},
  author={Doenges, Ryan and Kapp{\'e}, Tobias and Sarracino, John and Foster, Nate and Morrisett, Greg},
  booktitle={Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages={950--965},
  year={2022}
}

@inproceedings{vazou2014refinement,
  title={Refinement types for Haskell},
  author={Vazou, Niki and Seidel, Eric L and Jhala, Ranjit and Vytiniotis, Dimitrios and Peyton-Jones, Simon},
  booktitle={Proceedings of the 19th ACM SIGPLAN international conference on Functional programming},
  pages={269--282},
  year={2014}
}

@article{nelson1980fast,
  title={Fast decision procedures based on congruence closure},
  author={Nelson, Greg and Oppen, Derek C},
  journal={Journal of the ACM (JACM)},
  volume={27},
  number={2},
  pages={356--364},
  year={1980},
  publisher={ACM New York, NY, USA}
}

@phdthesis{munoz1994demonstration,
  title={D{\'e}monstration automatique dans la logique propositionnelle intuitionniste},
  author={Mu{\~n}oz, Cesar},
  year={1994},
  school={Master’s thesis, DEA d’Informatique Fondamentale, Universit{\'e} Paris 7}
}

@inproceedings{leino2016trigger,
  title={Trigger selection strategies to stabilize program verifiers},
  author={Leino, K Rustan M and Pit-Claudel, Cl{\'e}ment},
  booktitle={International Conference on Computer Aided Verification},
  pages={361--381},
  year={2016},
  organization={Springer}
}

@inproceedings{becker2019axiom,
  title={The axiom profiler: Understanding and debugging smt quantifier instantiations},
  author={Becker, Nils and M{\"u}ller, Peter and Summers, Alexander J},
  booktitle={International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  pages={99--116},
  year={2019},
  organization={Springer}
}

@inproceedings{goues2011boogie,
  title={The boogie verification debugger (tool paper)},
  author={Goues, Claire Le and Leino, K Rustan M and Moskal, Micha{\l}},
  booktitle={International Conference on Software Engineering and Formal Methods},
  pages={407--414},
  year={2011},
  organization={Springer}
}

@inproceedings{leino-monahan-2010,
  author    = {K. Rustan M. Leino and Rosemary Monahan},
  title     = {Dafny Meets the Verification Benchmarks Challenge},
  booktitle = {VSTTE},
  pages     = {112--126},
  year      = {2010},
  doi       = {10.1007/978-3-642-15057-9_8},
}

@inproceedings{vazou-etal-2014,
  author    = {Niki Vazou and Eric L. Seidel and Ranjit Jhala},
  title     = {LiquidHaskell: experience with refinement types in the real world},
  booktitle = {{ACM} {SIGPLAN} Haskell},
  pages     = {39--51},
  year      = {2014},
  doi       = {10.1145/2633357.2633366},
}

@incollection{lamport-1999,
  author    = {Lamport, Leslie},
  title     = {Specifying Concurrent Systems with TLA+},
  booktitle = {Calculational System Design},
  editor    = {M. Broy and R. Steinbrüggen},
  year      = {1999},
  url       = {https://www.microsoft.com/en-us/research/publication/specifying-concurrent-systems-tla/},
  pages     = {183-247},
}

@inproceedings{lamport-2009,
  author    = {Leslie Lamport},
  editor    = {Martin Leucker and Carroll Morgan},
  title     = {The PlusCal Algorithm Language},
  booktitle = {ICTAC},
  pages     = {36--60},
  year      = {2009},
  doi       = {10.1007/978-3-642-03466-4\_2},
}

@article{paulson-1986,
  author    = {Lawrence C. Paulson},
  title     = {Natural Deduction as Higher-Order Resolution},
  journal   = {J. Log. Program.},
  volume    = {3},
  number    = {3},
  pages     = {237--258},
  year      = {1986},
  doi       = {10.1016/0743-1066(86)90015-4},
}

@incollection{gordon-1988,
  author    = {Michael J. C. Gordon},
  editor    = {Graham Birtwistle and P. A. Subrahmanyam},
  title     = {HOL: A Proof Generating System for Higher-Order Logic},
  booktitle = {VLSI Specification, Verification and Synthesis},
  year      = {1988},
  pages     = {73--128},
  doi       = {10.1007/978-1-4613-2007-4_3},
}

@inproceedings{owre-etal-1992,
  author    = {Sam Owre and John M. Rushby and Natarajan Shankar},
  title     = {{PVS:} {A} Prototype Verification System},
  booktitle = {CADE},
  pages     = {748--752},
  year      = {1992},
  doi       = {10.1007/3-540-55602-8_217},
}

@manual{coq-web,
  author    = {{\relax {Coq} {Development} {Team}}},
  title     = {The {Coq} Reference Manual, version 8.15},
  year      = {2022},
  note      = {Available electronically at \url{http://coq.inria.fr/doc}}
}

@inproceedings{demoura-etal-2015,
  author    = {Leonardo Mendon{\c{c}}a de Moura and Soonho Kong and Jeremy Avigad and Floris van Doorn and Jakob von Raumer},
  title     = {The Lean Theorem Prover (System Description)},
  booktitle = {CADE},
  pages     = {378--388},
  year      = {2015},
  doi       = {10.1007/978-3-319-21401-6_26},
}

@article{jung2018iris,
  title={Iris from the ground up: A modular foundation for higher-order concurrent separation logic},
  author={Jung, Ralf and Krebbers, Robbert and Jourdan, Jacques-Henri and Bizjak, Ale{\v{s}} and Birkedal, Lars and Dreyer, Derek},
  journal={Journal of Functional Programming},
  volume={28},
  year={2018},
  publisher={Cambridge University Press}
}



@article{BST07-JSAT,
   author = {Clark Barrett and Igor Shikanian and Cesare Tinelli},
   title = {An Abstract Decision Procedure for a Theory of Inductive Data
	Types},
   journal = {Journal on Satisfiability, Boolean Modeling and Computation},
   volume = {3},
   pages = {21--46},
   publisher = {IOS Press},
   year = {2007},
   issn = {1574-0617},
   url = {http://www.cs.stanford.edu/~barrett/pubs/BST07-JSAT.pdf}
}

@article{sozeau-etal-2020,
  author    = {Matthieu Sozeau and Abhishek Anand and Simon Boulier and Cyril Cohen and Yannick Forster and Fabian Kunze and Gregory Malecha and Nicolas Tabareau and Th{\'{e}}o Winterhalter},
  title     = {The MetaCoq Project},
  journal   = {J. Autom. Reason.},
  volume    = {64},
  number    = {5},
  pages     = {947--999},
  year      = {2020},
  doi       = {10.1007/s10817-019-09540-0},
}

@inproceedings{gregoire-mahboubi-2005,
  author    = {Benjamin Gr{\'{e}}goire and Assia Mahboubi},
  title     = {Proving Equalities in a Commutative Ring Done Right in Coq},
  booktitle = {TPHOLs},
  pages     = {98--113},
  year      = {2005},
  doi       = {10.1007/11541868_7},
}

@misc{omega,
  author    = {Pierre Cr\'{e}gut},
  title     = {Omega: a solver for quantifier-free problems in Presburger Arithmetic},
  url       = {https://coq.github.io/doc/V8.9.1/refman/addendum/omega.html},
}

@inproceedings{besson-2006,
  author    = {Fr{\'{e}}d{\'{e}}ric Besson},
  title     = {Fast Reflexive Arithmetic Tactics the Linear Case and Beyond},
  booktitle = {TYPES},
  pages     = {48--62},
  year      = {2006},
  doi       = {10.1007/978-3-540-74464-1_4},
}

@article{gonthier2008formal,
  title={Formal proof--the four-color theorem},
  author={Gonthier, Georges and others},
  journal={Notices of the AMS},
  volume={55},
  number={11},
  pages={1382--1393},
  year={2008}
}

@inproceedings{gordon2000lcf,
  title={From LCF to HOL: a short history.},
  author={Gordon, Mike},
  booktitle={Proof, language, and interaction},
  pages={169--186},
  year={2000},
  organization={Citeseer}
}

@inproceedings{bohme2010fast,
  title={Fast LCF-style proof reconstruction for Z3},
  author={B{\"o}hme, Sascha and Weber, Tjark},
  booktitle={International Conference on Interactive Theorem Proving},
  pages={179--194},
  year={2010},
  organization={Springer}
}

@book{vfa,
  author    = {Andrew W. Appel},
  title     = {Verified Functional Algorithms},
  year      = {2022},
  url       = {https://softwarefoundations.cis.upenn.edu/vfa-current/index.html}
}

@article{compcert,
  author    = {Xavier Leroy},
  title     = {Formal verification of a realistic compiler},
  journal   = {Commun. {ACM}},
  volume    = {52},
  number    = {7},
  pages     = {107--115},
  year      = {2009},
  doi       = {10.1145/1538788.1538814},
}

@techreport{gonthier:inria-00407778,
  TITLE = {{An Ssreflect Tutorial}},
  AUTHOR = {Gonthier, Georges and St{\'e}phane Le, Roux},
  URL = {https://hal.inria.fr/inria-00407778},
  TYPE = {Technical Report},
  NUMBER = {RT-0367},
  PAGES = {33},
  INSTITUTION = {{INRIA}},
  YEAR = {2009},
  KEYWORDS = {proof assistants ; formal proofs ; Coq ; small scale reflection ; tactics},
  PDF = {https://hal.inria.fr/inria-00407778/file/RT-367.pdf},
  HAL_ID = {inria-00407778},
  HAL_VERSION = {v1},
}

@book{cpdt,
  author    = {Adam Chlipala},
  title     = {Certified Programming with Dependent Types - {A} Pragmatic Introduction to the Coq Proof Assistant},
  publisher = {{MIT} Press},
  year      = {2013},
  url       = {http://adam.chlipala.net/cpdt/},
  isbn      = {978-0-262-02665-9},
}

